"""
Twitter OAuth 2.0 Service with PKCE
Handles authentication and token management for Twitter API v2

PKCE (Proof Key for Code Exchange) is required for all Twitter OAuth 2.0 flows.
This provides enhanced security by preventing authorization code interception.

Documentation: https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code
"""
import httpx
import secrets
import hashlib
import base64
import logging
from typing import Dict, Optional, Tuple
from urllib.parse import urlencode
from datetime import datetime, timedelta

from app.core.config import settings
from app.core.logging_config import get_logger, log_event

logger = get_logger(__name__)


class TwitterOAuthService:
    """
    Service for handling Twitter OAuth 2.0 authentication with PKCE
    
    Twitter API v2 requires OAuth 2.0 with PKCE for enhanced security.
    Unlike LinkedIn, Twitter provides refresh tokens for long-term access.
    """
    
    # Twitter OAuth 2.0 endpoints
    AUTH_URL = "https://twitter.com/i/oauth2/authorize"
    TOKEN_URL = "https://api.twitter.com/2/oauth2/token"
    REVOKE_URL = "https://api.twitter.com/2/oauth2/revoke"
    USER_URL = "https://api.twitter.com/2/users/me"
    
    # OAuth scopes needed for posting tweets and reading user info
    SCOPES = [
        "tweet.read",       # Read user's tweets
        "tweet.write",      # Post tweets on behalf of user
        "users.read",       # Read user profile information
        "offline.access",   # Get refresh tokens for long-term access
    ]
    
    def __init__(self):
        self.client_id = settings.TWITTER_CLIENT_ID
        # Note: Twitter OAuth 2.0 with PKCE doesn't require client_secret for authorization
        # but it's needed for token exchange and refresh
        self.client_secret = settings.TWITTER_CLIENT_SECRET
        self.redirect_uri = settings.TWITTER_REDIRECT_URI
        logger.debug("Initialized TwitterOAuthService")
    
    def generate_state(self) -> str:
        """
        Generate cryptographically secure random state for CSRF protection
        
        Returns:
            Random state string (32 bytes URL-safe)
        """
        return secrets.token_urlsafe(32)
    
    def generate_code_verifier(self) -> str:
        """
        Generate a cryptographically random code verifier for PKCE
        
        PKCE spec requires 43-128 character string using [A-Z][a-z][0-9]-._~
        Using secrets.token_urlsafe(96) generates 128 characters.
        
        Returns:
            Random code verifier string (128 chars)
        """
        verifier = secrets.token_urlsafe(96)
        logger.debug(f"Generated PKCE code verifier: {verifier[:8]}...")
        return verifier
    
    def generate_code_challenge(self, code_verifier: str) -> str:
        """
        Generate code challenge from code verifier using SHA256
        
        PKCE flow:
        1. code_verifier = random string
        2. code_challenge = BASE64URL(SHA256(code_verifier))
        3. Send code_challenge to authorization endpoint
        4. Send code_verifier to token endpoint
        
        Args:
            code_verifier: Random string generated by generate_code_verifier()
            
        Returns:
            Base64-URL-encoded SHA256 hash of code_verifier
        """
        # Hash the verifier with SHA256
        digest = hashlib.sha256(code_verifier.encode('utf-8')).digest()
        
        # Base64-URL encode the hash (without padding)
        challenge = base64.urlsafe_b64encode(digest).decode('utf-8')
        challenge = challenge.rstrip('=')  # Remove padding
        
        logger.debug(f"Generated PKCE code challenge: {challenge[:8]}...")
        return challenge
    
    def get_authorization_url(self, state: Optional[str] = None, code_challenge: Optional[str] = None) -> Tuple[str, str, str]:
        """
        Generate Twitter authorization URL with PKCE challenge
        
        If state or code_challenge not provided, they will be generated automatically.
        Returns all three values for storage: URL, state, and code_verifier.
        
        Args:
            state: Random state parameter for CSRF protection (optional, will be generated)
            code_challenge: SHA256 hash of code_verifier (optional, will be generated)
            
        Returns:
            Tuple of (authorization_url, state, code_verifier)
            Store state and code_verifier for callback validation
        """
        # Generate state if not provided
        if not state:
            state = self.generate_state()
        
        # Generate code verifier and challenge if not provided
        code_verifier = self.generate_code_verifier()
        if not code_challenge:
            code_challenge = self.generate_code_challenge(code_verifier)
        
        params = {
            "response_type": "code",
            "client_id": self.client_id,
            "redirect_uri": self.redirect_uri,
            "scope": " ".join(self.SCOPES),
            "state": state,
            "code_challenge": code_challenge,
            "code_challenge_method": "S256",  # SHA256 hashing method
        }
        
        url = f"{self.AUTH_URL}?{urlencode(params)}"
        logger.info(f"Generated Twitter authorization URL with state: {state[:8]}...")
        return url, state, code_verifier
    
    async def exchange_code_for_token(self, code: str, code_verifier: str) -> Dict:
        """
        Exchange authorization code for access token using PKCE
        
        This is where the PKCE magic happens: we send the code_verifier
        to prove we're the same client that initiated the OAuth flow.
        
        Args:
            code: Authorization code from callback
            code_verifier: Original code verifier (not the challenge!)
            
        Returns:
            Dict containing:
                - access_token: Short-lived token (2 hours)
                - refresh_token: Long-lived token for getting new access tokens
                - expires_in: Seconds until access token expires (7200 = 2 hours)
                - token_type: "bearer"
                - scope: Space-separated list of granted scopes
            
        Raises:
            httpx.HTTPError: If token exchange fails
        """
        # Twitter requires Basic authentication with client credentials
        auth = (self.client_id, self.client_secret)
        
        data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": self.redirect_uri,
            "code_verifier": code_verifier,  # Critical: proves we're the original client
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.TOKEN_URL,
                    data=data,
                    auth=auth,
                    headers={"Content-Type": "application/x-www-form-urlencoded"}
                )
                response.raise_for_status()
                token_data = response.json()
                
                expires_in = token_data.get("expires_in", 7200)
                logger.info(f"Successfully exchanged code for Twitter token (expires in {expires_in}s)")
                return token_data
        
        except httpx.HTTPError as e:
            logger.error(f"Failed to exchange Twitter code for token: {e}")
            raise
    
    async def refresh_access_token(self, refresh_token: str) -> Dict:
        """
        Refresh an expired access token using refresh token
        
        Twitter access tokens expire after 2 hours. Refresh tokens are long-lived
        and can be used to get new access tokens without user re-authentication.
        
        Args:
            refresh_token: Refresh token from initial authorization or previous refresh
            
        Returns:
            Dict containing new access_token, refresh_token, expires_in, etc.
            Note: A new refresh_token is also returned. Always update stored token!
            
        Raises:
            httpx.HTTPError: If token refresh fails
        """
        # Twitter requires Basic authentication with client credentials
        auth = (self.client_id, self.client_secret)
        
        data = {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.TOKEN_URL,
                    data=data,
                    auth=auth,
                    headers={"Content-Type": "application/x-www-form-urlencoded"}
                )
                response.raise_for_status()
                
                # IMPORTANT: Twitter returns a NEW refresh token
                # The old refresh token is invalidated
                token_data = response.json()
                logger.info("Successfully refreshed Twitter access token (new refresh token issued)")
                return token_data
        
        except httpx.HTTPError as e:
            logger.error(f"Failed to refresh Twitter token: {e}")
            raise
    
    async def revoke_token(self, token: str, token_type: str = "access_token") -> bool:
        """
        Revoke an access token or refresh token
        
        Args:
            token: Token to revoke
            token_type: "access_token" or "refresh_token"
            
        Returns:
            True if revocation successful
            
        Raises:
            httpx.HTTPError: If revocation fails
        """
        # Twitter requires Basic authentication with client credentials
        auth = (self.client_id, self.client_secret)
        
        data = {
            "token": token,
            "token_type_hint": token_type,
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.REVOKE_URL,
                    data=data,
                    auth=auth,
                    headers={"Content-Type": "application/x-www-form-urlencoded"}
                )
                response.raise_for_status()
                logger.info(f"Successfully revoked Twitter {token_type}")
                return True
        
        except httpx.HTTPError as e:
            logger.error(f"Failed to revoke Twitter token: {e}")
            return False
    
    async def get_user_profile(self, access_token: str) -> Dict:
        """
        Fetch user profile information using access token
        
        Uses Twitter API v2 /users/me endpoint to get authenticated user's info.
        
        Args:
            access_token: Twitter access token
            
        Returns:
            Dict containing user data:
                - id: User's Twitter ID
                - name: Display name
                - username: @handle (without @)
                - profile_image_url: Profile picture URL (optional)
                - verified: Blue checkmark status (optional)
            
        Raises:
            httpx.HTTPError: If profile fetch fails
        """
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        
        # Request additional user fields
        params = {
            "user.fields": "id,name,username,profile_image_url,verified"
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    self.USER_URL,
                    headers=headers,
                    params=params
                )
                response.raise_for_status()
                
                # Twitter API v2 wraps response in "data" object
                result = response.json()
                user_data = result.get("data", result)
                
                user_id = user_data.get("id", "unknown")
                username = user_data.get("username", "unknown")
                logger.info(f"Successfully fetched Twitter profile for @{username} (ID: {user_id})")
                
                return user_data
        
        except httpx.HTTPError as e:
            logger.error(f"Failed to fetch Twitter profile: {e}")
            raise
    
    def calculate_token_expiry(self, expires_in: int) -> datetime:
        """
        Calculate token expiration datetime
        
        Twitter access tokens expire after 2 hours (7200 seconds).
        We calculate the exact expiration time for proactive refresh.
        
        Args:
            expires_in: Seconds until token expires (typically 7200)
            
        Returns:
            Datetime when token will expire
        """
        expiry = datetime.utcnow() + timedelta(seconds=expires_in)
        logger.debug(f"Twitter token will expire at: {expiry.isoformat()}")
        return expiry
    
    def is_token_expired(self, expires_at: datetime) -> bool:
        """
        Check if a token has expired.
        
        Args:
            expires_at: Token expiration datetime
            
        Returns:
            True if token has expired or will expire within 5 minutes
        """
        # Consider token expired if less than 5 minutes remaining
        buffer = timedelta(minutes=5)
        is_expired = datetime.utcnow() + buffer >= expires_at
        
        if is_expired:
            logger.info(f"Twitter token expired or expiring soon (expires at {expires_at.isoformat()})")
        
        return is_expired
    
    def should_refresh_token(self, expires_at: datetime) -> bool:
        """
        Check if token should be refreshed
        
        We refresh proactively 5 minutes before expiration to avoid
        race conditions where token expires during API call.
        
        Args:
            expires_at: Token expiration datetime
            
        Returns:
            True if token should be refreshed
        """
        return self.is_token_expired(expires_at)


# Global instance
twitter_oauth = TwitterOAuthService()
