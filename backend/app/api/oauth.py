"""
OAuth 2.0 API Router - Unified endpoints for all platforms
Supports LinkedIn, Twitter, and Meta OAuth flows
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Dict, Optional
from datetime import datetime

from app.db.database import get_db
from app.models.business import Business
from app.models.social_account import SocialAccount
from app.services.oauth_linkedin import linkedin_oauth
from app.services.oauth_twitter import twitter_oauth
from app.services.oauth_meta import meta_oauth
from app.core.security import token_encryption, state_manager
from app.core.logging_config import get_logger
from app.core.sentry_config import add_breadcrumb, set_user_context

logger = get_logger(__name__)

router = APIRouter(prefix="/oauth", tags=["OAuth"])


# OAuth service mapping
OAUTH_SERVICES = {
    "linkedin": linkedin_oauth,
    "twitter": twitter_oauth,
    "meta": meta_oauth,
}


def get_oauth_service(platform: str):
    """Get OAuth service for platform"""
    service = OAUTH_SERVICES.get(platform.lower())
    if not service:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported platform: {platform}. Supported: {list(OAUTH_SERVICES.keys())}"
        )
    return service


@router.get("/platforms")
async def list_available_platforms():
    """
    List all supported OAuth platforms.
    
    Returns:
        List of platform names with their configuration status
    """
    platforms = []
    for name, service in OAUTH_SERVICES.items():
        # Check if service is configured
        is_configured = hasattr(service, 'client_id') and service.client_id
        
        platforms.append({
            "name": name,
            "configured": is_configured,
            "authorization_url": f"/api/v1/oauth/{name}/authorize"
        })
    
    logger.info(f"Listed {len(platforms)} available OAuth platforms")
    return {"platforms": platforms}


@router.get("/{platform}/authorize")
async def initiate_oauth(
    platform: str,
    business_id: int = Query(..., description="Business ID for OAuth connection"),
    redirect_uri: Optional[str] = Query(None, description="Custom redirect URI"),
    db: Session = Depends(get_db)
):
    """
    Initiate OAuth flow for a platform.
    
    Args:
        platform: Platform name (linkedin, twitter, meta)
        business_id: Business to connect account to
        redirect_uri: Optional custom redirect URI
        
    Returns:
        Authorization URL and state parameter (and code_verifier for Twitter)
    """
    # Validate business exists
    business = db.query(Business).filter(Business.id == business_id).first()
    if not business:
        raise HTTPException(status_code=404, detail="Business not found")
    
    # Get OAuth service
    service = get_oauth_service(platform)
    
    try:
        # Generate authorization URL with state
        # LinkedIn returns (url, state)
        # Twitter returns (url, state, code_verifier)
        auth_result = service.get_authorization_url(state=None)
        
        # Handle different return types
        if len(auth_result) == 2:
            # LinkedIn and Meta: (url, state)
            auth_url, oauth_state = auth_result
            code_verifier = None
        elif len(auth_result) == 3:
            # Twitter: (url, state, code_verifier)
            auth_url, oauth_state, code_verifier = auth_result
        else:
            raise ValueError(f"Unexpected return type from {platform} OAuth service")
        
        # Store the OAuth provider's state with business_id and platform for validation
        # We use the state generated by the OAuth service, not create a new one
        # This also stores code_verifier for Twitter (PKCE)
        state_manager.store_state(
            state=oauth_state,
            business_id=business_id,
            platform=platform,
            code_verifier=code_verifier
        )
        
        logger.info(f"Initiated {platform} OAuth for business {business_id}, state={oauth_state[:8]}...")
        
        response = {
            "authorization_url": auth_url,
            "state": oauth_state,
            "platform": platform,
            "business_id": business_id
        }
        
        # Note: code_verifier is stored in state_manager, not returned to client
        # This is more secure than returning it in the response
        
        return response
    
    except Exception as e:
        logger.error(f"Failed to initiate {platform} OAuth: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to initiate OAuth: {str(e)}")


@router.get("/{platform}/callback")
async def handle_oauth_callback(
    platform: str,
    code: str = Query(..., description="Authorization code from OAuth provider"),
    state: str = Query(..., description="State parameter for CSRF validation"),
    db: Session = Depends(get_db)
):
    """
    Handle OAuth callback from provider.
    
    Args:
        platform: Platform name
        code: Authorization code
        state: State parameter for CSRF validation
        
    Returns:
        Success message with account details
        
    Note: business_id and code_verifier are retrieved from state_manager
    """
    # First, retrieve state data to get business_id
    try:
        # Validate state and get stored data (business_id, platform, code_verifier)
        state_data = state_manager.validate_state_no_business(state)
        business_id = state_data.get("business_id")
        stored_platform = state_data.get("platform")
        code_verifier = state_data.get("code_verifier")  # For Twitter PKCE
        
        # Verify platform matches
        if stored_platform != platform:
            raise ValueError(f"Platform mismatch: expected {stored_platform}, got {platform}")
        
        if not business_id:
            raise ValueError("business_id not found in state data")
            
    except ValueError as e:
        logger.warning(f"State validation failed: {e}")
        add_breadcrumb(
            category='oauth',
            message='State validation failed',
            level='error',
            data={'error': str(e), 'platform': platform}
        )
        raise HTTPException(status_code=400, detail=str(e))
    
    # Validate business exists
    business = db.query(Business).filter(Business.id == business_id).first()
    if not business:
        raise HTTPException(status_code=404, detail="Business not found")
    
    # Add Sentry breadcrumb
    add_breadcrumb(
        category='oauth',
        message=f'OAuth callback received for {platform}',
        level='info',
        data={
            'platform': platform,
            'business_id': business_id,
            'has_code': bool(code),
            'has_state': bool(state),
        }
    )
    
    # Set user context for Sentry
    set_user_context(business_id=business_id)
    
    # State already validated above
    add_breadcrumb(
        category='oauth',
        message='State validation successful',
        level='info',
        data={'platform': platform}
    )
    
    # Get OAuth service
    service = get_oauth_service(platform)
    
    try:
        # Exchange code for token
        # Twitter requires code_verifier for PKCE
        if platform.lower() == "twitter":
            if not code_verifier:
                raise HTTPException(
                    status_code=500,
                    detail="code_verifier not found in state (internal error)"
                )
            token_data = await service.exchange_code_for_token(code, code_verifier)
        else:
            token_data = await service.exchange_code_for_token(code)
        
        access_token = token_data.get("access_token")
        refresh_token = token_data.get("refresh_token")  # Twitter provides this
        expires_in = token_data.get("expires_in", 5184000)  # Default 60 days (LinkedIn)
        
        # Get user profile
        profile = await service.get_user_profile(access_token)
        
        # Calculate token expiry
        expires_at = service.calculate_token_expiry(expires_in)
        
        # Encrypt tokens before storing
        encrypted_access_token = token_encryption.encrypt_token(access_token)
        encrypted_refresh_token = token_encryption.encrypt_if_present(refresh_token)
        
        # Store or update social account
        existing_account = db.query(SocialAccount).filter(
            SocialAccount.business_id == business_id,
            SocialAccount.platform == platform
        ).first()
        
        if existing_account:
            # Update existing account
            existing_account.access_token = encrypted_access_token
            existing_account.refresh_token = encrypted_refresh_token
            existing_account.token_expires_at = expires_at
            existing_account.platform_user_id = profile.get("sub") or profile.get("id")
            existing_account.platform_username = profile.get("name") or profile.get("username")
            existing_account.is_active = True
            existing_account.updated_at = datetime.utcnow()
            logger.info(f"Updated existing {platform} account for business {business_id}")
        else:
            # Create new account
            new_account = SocialAccount(
                business_id=business_id,
                platform=platform,
                platform_user_id=profile.get("sub") or profile.get("id"),
                platform_username=profile.get("name") or profile.get("username"),
                access_token=encrypted_access_token,
                refresh_token=encrypted_refresh_token,
                token_expires_at=expires_at,
                is_active=True
            )
            db.add(new_account)
            logger.info(f"Created new {platform} account for business {business_id}")
        
        db.commit()
        
        logger.info(f"Successfully connected {platform} account for business {business_id} (token encrypted)")
        
        return {
            "success": True,
            "platform": platform,
            "business_id": business_id,
            "profile": {
                "name": profile.get("name") or profile.get("username"),
                "id": profile.get("sub") or profile.get("id"),
                "email": profile.get("email")
            },
            "expires_at": expires_at.isoformat()
        }
    
    except Exception as e:
        logger.error(f"Failed to handle {platform} OAuth callback: {e}")
        raise HTTPException(status_code=500, detail=f"OAuth callback failed: {str(e)}")


@router.post("/{platform}/refresh")
async def refresh_oauth_token(
    platform: str,
    business_id: int = Query(..., description="Business ID"),
    db: Session = Depends(get_db)
):
    """
    Refresh expired OAuth token.
    
    Args:
        platform: Platform name
        business_id: Business ID
        
    Returns:
        New token details
    """
    # Validate business exists
    business = db.query(Business).filter(Business.id == business_id).first()
    if not business:
        raise HTTPException(status_code=404, detail="Business not found")
    
    # Get social account
    social_account = db.query(SocialAccount).filter(
        SocialAccount.business_id == business_id,
        SocialAccount.platform == platform
    ).first()
    
    if not social_account:
        raise HTTPException(status_code=404, detail=f"No {platform} connection found")
    
    # Get OAuth service
    service = get_oauth_service(platform)
    
    try:
        # Check if token needs refresh
        if not social_account.token_expires_at:
            raise HTTPException(status_code=400, detail="Token expiration not found")
        
        if not service.is_token_expired(social_account.token_expires_at):
            logger.info(f"{platform} token for business {business_id} is still valid")
            return {
                "success": True,
                "message": "Token is still valid",
                "expires_at": social_account.token_expires_at.isoformat()
            }
        
        # Attempt token refresh
        # Note: LinkedIn doesn't support refresh tokens
        if not social_account.refresh_token:
            raise HTTPException(
                status_code=400,
                detail=f"{platform} requires re-authentication (no refresh token)"
            )
        
        # Decrypt refresh token
        refresh_token = token_encryption.decrypt_token(social_account.refresh_token)
        
        token_data = await service.refresh_access_token(refresh_token)
        access_token = token_data.get("access_token")
        new_refresh_token = token_data.get("refresh_token")  # Twitter returns new one
        expires_in = token_data.get("expires_in", 5184000)
        
        # Calculate new expiry
        new_expires_at = service.calculate_token_expiry(expires_in)
        
        # Encrypt tokens before storing
        encrypted_access_token = token_encryption.encrypt_token(access_token)
        encrypted_refresh_token = token_encryption.encrypt_if_present(new_refresh_token)
        
        # Update social account
        social_account.access_token = encrypted_access_token
        if encrypted_refresh_token:
            social_account.refresh_token = encrypted_refresh_token
        social_account.token_expires_at = new_expires_at
        social_account.updated_at = datetime.utcnow()
        db.commit()
        
        logger.info(f"Refreshed {platform} token for business {business_id}")
        
        return {
            "success": True,
            "platform": platform,
            "expires_at": new_expires_at.isoformat()
        }
    
    except NotImplementedError as e:
        logger.warning(f"{platform} does not support token refresh: {e}")
        raise HTTPException(
            status_code=501,
            detail=str(e)
        )
    
    except Exception as e:
        logger.error(f"Failed to refresh {platform} token: {e}")
        raise HTTPException(status_code=500, detail=f"Token refresh failed: {str(e)}")


@router.delete("/{platform}/disconnect")
async def disconnect_oauth(
    platform: str,
    business_id: int = Query(..., description="Business ID"),
    db: Session = Depends(get_db)
):
    """
    Disconnect OAuth account and revoke token.
    
    Args:
        platform: Platform name
        business_id: Business ID
        
    Returns:
        Success confirmation
    """
    # Validate business exists
    business = db.query(Business).filter(Business.id == business_id).first()
    if not business:
        raise HTTPException(status_code=404, detail="Business not found")
    
    # Get social account
    social_account = db.query(SocialAccount).filter(
        SocialAccount.business_id == business_id,
        SocialAccount.platform == platform
    ).first()
    
    if not social_account:
        raise HTTPException(status_code=404, detail=f"No {platform} connection found")
    
    # Get OAuth service
    service = get_oauth_service(platform)
    
    try:
        # Revoke token if service supports it
        if social_account.access_token and hasattr(service, 'revoke_token'):
            # Decrypt token for revocation
            access_token = token_encryption.decrypt_token(social_account.access_token)
            revoked = await service.revoke_token(access_token)
            if revoked:
                logger.info(f"Revoked {platform} token for business {business_id}")
            else:
                logger.warning(f"Failed to revoke {platform} token, but will remove locally")
        
        # Delete social account from database
        db.delete(social_account)
        db.commit()
        
        logger.info(f"Disconnected {platform} account for business {business_id}")
        
        return {
            "success": True,
            "platform": platform,
            "business_id": business_id,
            "message": f"{platform} account disconnected successfully"
        }
    
    except Exception as e:
        logger.error(f"Failed to disconnect {platform} account: {e}")
        raise HTTPException(status_code=500, detail=f"Disconnect failed: {str(e)}")


@router.get("/status")
async def get_oauth_status(
    business_id: int = Query(..., description="Business ID"),
    db: Session = Depends(get_db)
):
    """
    Get OAuth connection status for all platforms.
    
    Args:
        business_id: Business ID
        
    Returns:
        Status for each platform
    """
    # Validate business exists
    business = db.query(Business).filter(Business.id == business_id).first()
    if not business:
        raise HTTPException(status_code=404, detail="Business not found")
    
    # Get all social accounts for this business
    social_accounts = db.query(SocialAccount).filter(
        SocialAccount.business_id == business_id
    ).all()
    
    # Create a map of platform -> account
    accounts_map = {acc.platform: acc for acc in social_accounts}
    
    status = {}
    for platform_name, service in OAUTH_SERVICES.items():
        account = accounts_map.get(platform_name)
        
        if not account:
            status[platform_name] = {
                "connected": False,
                "status": "not_connected"
            }
            continue
        
        # Check token expiration
        if account.token_expires_at:
            is_expired = service.is_token_expired(account.token_expires_at)
            
            status[platform_name] = {
                "connected": True,
                "status": "expired" if is_expired else "active",
                "expires_at": account.token_expires_at.isoformat(),
                "profile": {
                    "username": account.platform_username,
                    "id": account.platform_user_id
                },
                "last_sync": account.last_sync.isoformat() if account.last_sync else None
            }
        else:
            status[platform_name] = {
                "connected": True,
                "status": "unknown",
                "profile": {
                    "username": account.platform_username,
                    "id": account.platform_user_id
                }
            }
    
    logger.info(f"Retrieved OAuth status for business {business_id}")
    
    return {
        "business_id": business_id,
        "platforms": status
    }
